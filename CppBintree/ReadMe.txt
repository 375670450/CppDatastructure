注意 :	1. 一般情况下不用自己定义oprerator=, 使用默认的赋值函数即可
		2. 为什么一插入重复元素则无法正常运行:
			因为插入函数中写成只有比较出两个元素的大小关系时才会改变循环变量(Node)
		3. 声明一个智能指针的时候要立即给它实例化， 而且一定【不能手动释放】它。
		4. 不要声明临时的share_ptr， 然后把这个指针传递给一个函数
		5. 树形输出方法:我们只需要在对树进行层次遍历，然后在输出每层最后一个节点之后
		再输出一个换行符即可。如何知道每层的最后一个结点是哪个呢？如果我们知道每一层
		一共有多少个节点，然后在输出的时候对已输出结点计数，就可以知道每层的最后一个
		结点是哪个。对于任意的一颗二叉树，我们虽然不知道任意一层的结点总数，但是我们
		知道第0层一定只有一个结点，就是根节点，第1层结点总数就是根结点的孩子结点总数，
		第2层结点总数就是第1层所有节点的孩子总数，以此类堆就可以知道所有层的结点总数，
		然后实现按层换行。

		5. 加入异常处理方法

		6. 类内有指针成员的时候最好重新定义复制构造函数, 析构函数

		7.  一开始总是在析构函数delete语句执行的时候产生异常中断, 是因为
			在构造函数new的时候错写变量名使得 new T[0]从而没有分配到内存,
			所以在析构的时候就出错了(但是在gcc编译环境下运行没有错误?)
		8. 把NODE_PTR的宏定义改为typedef